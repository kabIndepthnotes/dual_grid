@code_type c .c
@comment_type /* %s */
@compiler gcc main.c

@title An Indepthnotes Project

@s Introduction

- TODOs:
	- I want to make this into a library so that I can import it to new game codes.


I start of tautologically, please refer to https://github.com/raysan5/raylib/blob/master/examples/core/core_basic_window_web.c as it is almost exactly a copy to begin with.

@s Make Window And Raylib Example Window
I decided to make a web build primarily as especially for jams, not many people will download and play the game.

--- main.c
/* If you are using lit to compile, do not edit this file (platformer.c) directly as it will be overwritten in the main.lit compile process */
@{include_directives}
@{define_directives}
@{type_definitions}
@{external_variables}
@{function_prototypes}
int
main(void)
{
	SetConfigFlags(FLAG_VSYNC_HINT | FLAG_MSAA_4X_HINT | FLAG_WINDOW_HIGHDPI);
	InitWindow(screen_width, screen_height, "game");
	@{initialise_objects}
#if defined(__EMSCRIPTEN__)
	emscripten_set_main_loop(update_draw_frame, 0, 1);
#else
	SetTargetFPS(60);
	while (!WindowShouldClose())
	{
		update_draw_frame();
	}
#endif
	@{de_init}
	CloseWindow();
	return 0;
}

@{function_definitions}

---

--- include_directives
#include "raylib.h" // itself includes stdbool.h and stdarg.h
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#if defined(__EMSCRIPTEN__)
	#include <emscripten/emscripten.h>
#endif
---

--- external_variables
/* const int screen_width = 800; */
/* const int screen_height = 450; */
const int screen_width = 1280;
const int screen_height = 1024;
---

@s Update Draw Loop

--- function_prototypes
void update_draw_frame(void);
---

--- function_definitions
void
update_draw_frame(void)
{
	@{update}
	
	/* opengl draw context */
	BeginDrawing();
	ClearBackground(RAYWHITE);
	@{draw}
	EndDrawing();
}
---

@s How The Dual tile set works

The dual tile set works by thinking about intersections of the grid rather than the grid itself.
We essentially compare four numbers, here, right, below and [below and right] and we match the pattern with the corresponding tile (see below)

- We need 6 tile types each with 1, 2, or 4 rotations:

- Outer corner

$$\begin{matrix} 1 & 0 \\
                 0 & 0 \end{matrix}$$

$$\begin{matrix} 0 & 1 \\
				 0 & 0 \end{matrix}$$

$$\begin{matrix} 0 & 0 \\
				 0 & 1 \end{matrix}$$

$$\begin{matrix} 0 & 0 \\
				 1 & 0 \end{matrix}$$

- Edge connector

$$\begin{matrix} 1 & 0 \\
				 0 & 1 \end{matrix}$$

$$\begin{matrix} 0 & 1 \\
				 1 & 0 \end{matrix}$$

- Inner corner

$$\begin{matrix} 0 & 1 \\
				 1 & 1 \end{matrix}$$

$$\begin{matrix} 1 & 0 \\
				 1 & 1 \end{matrix}$$

$$\begin{matrix} 1 & 1 \\
				 1 & 0 \end{matrix}$$

$$\begin{matrix} 1 & 1 \\
				 0 & 1 \end{matrix}$$
- Border

$$\begin{matrix} 1 & 1 \\
				 0 & 0 \end{matrix}$$

$$\begin{matrix} 0 & 1 \\
				 0 & 1 \end{matrix}$$

$$\begin{matrix} 0 & 0 \\
				 1 & 1 \end{matrix}$$

$$\begin{matrix} 1 & 0 \\
				 1 & 0 \end{matrix}$$


- Overlay fill

$$\begin{matrix} 1 & 1 \\
				 1 & 1 \end{matrix}$$

- Underlay fill

$$\begin{matrix} 0 & 0 \\
				 0 & 0 \end{matrix}$$

--- type_definitions
enum dual_tile_type {
	OUTER_CORNER_0,
	OUTER_CORNER_1,
	OUTER_CORNER_2,
	OUTER_CORNER_3,
	EDGE_CONNECTOR_0,
	EDGE_CONNECTOR_1,
	INNER_CORNER_0,
	INNER_CORNER_1,
	INNER_CORNER_2,
	INNER_CORNER_3,
	BORDER_0,
	BORDER_1,
	BORDER_2,
	BORDER_3,
	OVERLAY_FILL_0,
	UNDERLAY_FILL_0,
};
---

@s converting a drawing into a tileset text file

I want a setup where I make a bitmap file for the world, and use bash to process the text.
See "lit/giftotileset.lit"

--- ../include/tilemap.h
extern int tileset_n[22][40];
---

--- include_directives +=
#include "tilemap.h"
---

We need to populate the `dual_grid`.

--- external_variables +=
int tileset_0_dual[22][40];
---


--- initialise_objects
int pos_0, pos_1, pos_2, pos_3;
for (int x = 0; x < 40 - 1; x++) {
	for (int y = 0; y < 22 - 1; y++) {
		/* outer corner */
		pos_0 = tileset_n[y][x];
		pos_1 = tileset_n[y][x+1];
		pos_2 = tileset_n[y+1][x];
		pos_3 = tileset_n[y+1][x+1];

		/* outer corner */
		if (is_tile(pos_0, pos_1, pos_2, pos_3, 1 ,0 ,0 ,0)){
			tileset_0_dual[y][x] = OUTER_CORNER_0;
		}
		else if (is_tile(pos_0, pos_1, pos_2, pos_3, 0 ,1 ,0 ,0)) {
			tileset_0_dual[y][x] = OUTER_CORNER_1;
		}
		else if (is_tile(pos_0, pos_1, pos_2, pos_3, 0 ,0 ,0 ,1)) {
			tileset_0_dual[y][x] = OUTER_CORNER_2;
		}
		else if (is_tile(pos_0, pos_1, pos_2, pos_3, 0 ,0 ,1 ,0)) {
			tileset_0_dual[y][x] = OUTER_CORNER_3;
		}

		/* edge connectors */
		else if (is_tile(pos_0, pos_1, pos_2, pos_3, 1 ,0 ,0 ,1)) {
			tileset_0_dual[y][x] = EDGE_CONNECTOR_0;
		}
		else if (is_tile(pos_0, pos_1, pos_2, pos_3, 0 ,1 ,1 ,0)) {
			tileset_0_dual[y][x] = EDGE_CONNECTOR_1;
		}

		/* inner corner */
		else if (is_tile(pos_0, pos_1, pos_2, pos_3, 0 ,1 ,1 ,1)) {
			tileset_0_dual[y][x] = INNER_CORNER_0;
		}
		else if (is_tile(pos_0, pos_1, pos_2, pos_3, 1 ,0 ,1 ,1)) {
			tileset_0_dual[y][x] = INNER_CORNER_1;
		}
		else if (is_tile(pos_0, pos_1, pos_2, pos_3, 1 ,1 ,1 ,0)) {
			tileset_0_dual[y][x] = INNER_CORNER_2;
		}
		else if (is_tile(pos_0, pos_1, pos_2, pos_3, 1 ,1 ,0 ,1)) {
			tileset_0_dual[y][x] = INNER_CORNER_3;
		}

		/* border */
		else if (is_tile(pos_0, pos_1, pos_2, pos_3, 1 ,1 ,0 ,0)) {
			tileset_0_dual[y][x] = BORDER_0;
		}
		else if (is_tile(pos_0, pos_1, pos_2, pos_3, 0 ,1 ,0 ,1)) {
			tileset_0_dual[y][x] = BORDER_1;
		}
		else if (is_tile(pos_0, pos_1, pos_2, pos_3, 0 ,0 ,1 ,1)) {
			tileset_0_dual[y][x] = BORDER_2;
		}
		else if (is_tile(pos_0, pos_1, pos_2, pos_3, 1 ,0 ,1 ,0)) {
			tileset_0_dual[y][x] = BORDER_3;
		}

		/* overlay fill */
		else if (is_tile(pos_0, pos_1, pos_2, pos_3, 1 ,1 ,1 ,1)) {
			tileset_0_dual[y][x] = OVERLAY_FILL_0;
		}

		/* underlay fill */
		else if (is_tile(pos_0, pos_1, pos_2, pos_3, 0 ,0 ,0 ,0)) {
			tileset_0_dual[y][x] = UNDERLAY_FILL_0;
		}

	}
}
---

--- function_prototypes +=
bool is_tile(int x_0, int x_1, int x_2, int x_3, int y_0, int y_1, int y_2, int y_3);
---

--- function_definitions +=
bool
is_tile(int x_0, int x_1, int x_2, int x_3, int y_0, int y_1, int y_2, int y_3)
{
	if (x_0 == y_0 && x_1 == y_1 && x_2 == y_2 && x_3 == y_3) {
		return true;
	}
	return false;
}
---


--- function_prototypes +=
void draw_layer_0(int tileset_0_dual[22][40]);
---

--- function_definitions +=
void
draw_layer_0(int tileset_0_dual[22][40])
{
	for (int x = 0; x < 40 - 1; x++) {
		for (int y = 0; y < 22 - 1; y++) {
			Vector2 draw_pos = {x*(TILESIZE*TILESCALE), y*(TILESIZE*TILESCALE)};
			int tile = tileset_0_dual[y][x];
			DrawTextureEx(layer_0[tile], draw_pos, 0, TILESCALE, WHITE);
		}
	}
}
---

--- draw
draw_layer_0(tileset_0_dual);
---


--- define_directives
#define TILESIZE 16
#define TILESCALE 2
---


--- external_variables +=
Texture2D layer_0[UNDERLAY_FILL_0 + 1]; // UNDERLAY_FILL_0 is the last enum
---

TODO if optimize needed, we should load one big texture then draw each accordingly.
--- initialise_objects +=
layer_0[OUTER_CORNER_0] = LoadTexture("assets/tileset1/outer_corner_0.gif");
layer_0[OUTER_CORNER_1] = LoadTexture("assets/tileset1/outer_corner_1.gif");
layer_0[OUTER_CORNER_2] = LoadTexture("assets/tileset1/outer_corner_2.gif");
layer_0[OUTER_CORNER_3] = LoadTexture("assets/tileset1/outer_corner_3.gif");
layer_0[EDGE_CONNECTOR_0] = LoadTexture("assets/tileset1/edge_connector_0.gif");
layer_0[EDGE_CONNECTOR_1] = LoadTexture("assets/tileset1/edge_connector_1.gif");
layer_0[INNER_CORNER_0] = LoadTexture("assets/tileset1/inner_corner_0.gif");
layer_0[INNER_CORNER_1] = LoadTexture("assets/tileset1/inner_corner_1.gif");
layer_0[INNER_CORNER_2] = LoadTexture("assets/tileset1/inner_corner_2.gif");
layer_0[INNER_CORNER_3] = LoadTexture("assets/tileset1/inner_corner_3.gif");
layer_0[BORDER_0] = LoadTexture("assets/tileset1/border_0.gif");
layer_0[BORDER_1] = LoadTexture("assets/tileset1/border_1.gif");
layer_0[BORDER_2] = LoadTexture("assets/tileset1/border_2.gif");
layer_0[BORDER_3] = LoadTexture("assets/tileset1/border_3.gif");
layer_0[OVERLAY_FILL_0] = LoadTexture("assets/tileset1/overlay_fill_0.gif");
layer_0[UNDERLAY_FILL_0] = LoadTexture("assets/tileset1/underlay_fill_0.gif");
---

--- de_init
for (int i = 0; i < UNDERLAY_FILL_0; i++) {
	UnloadTexture(layer_0[i]);
}
---







@s debug lit program
move these to main code when appropriate

--- update

---



